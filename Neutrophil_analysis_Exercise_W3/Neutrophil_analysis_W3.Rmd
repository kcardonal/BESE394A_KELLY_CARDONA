---
title: "Neutrophil ATACseq analysis (3h, 6h, and 12h)"
author: "Group 2: Alejandra Lopez | Kelly Cardona | Giulia Sansone"
date: "2024-02-07"
output: 
  html_document:
    theme: cosmo
---

```{r setup, include=FALSE}
#knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

## Finding consensus peaks

description

```{r message=FALSE}
# Script for finding consensus peaks
rm(list = ls())
library(rtracklayer)
library(GenomicRanges)
library(knitr)

#setwd

# control panel
raw_data_folder <- './ATACseq/beds/'
min_overlap <- 0.3
chromosomes <- paste0('chr', c(1:22, 'X', 'Y'))

# bed files 
bed_files <- file.path(raw_data_folder, 
                       dir(raw_data_folder, pattern = '*.bed'))
bed_files <- bed_files[1:12]
bed_files
```

```{r}
# function for finding intersecting peaks
find_intersection <- function(reference_bed, subject_bed, chromosomes){
  
  # subsetting 
  reference_bed <- reference_bed[seqnames(reference_bed) %in% chromosomes]
  seqlevels(reference_bed) <- chromosomes
  subject_bed <- subject_bed[seqnames(subject_bed) %in% chromosomes]
  seqlevels(subject_bed) <- chromosomes
  
  # finding overlap between the two files
  hits <- findOverlaps(reference_bed, subject_bed)
  overlaps <- pintersect(reference_bed[queryHits(hits)], 
                         subject_bed[subjectHits(hits)])
  
  # overlap fraction with respect to the original peaks
  percent_overlap_on_1 <- width(overlaps) / width(reference_bed[queryHits(hits)])
  percent_overlap_on_2 <- width(overlaps) / width(subject_bed[subjectHits(hits)])
  hits <- hits[percent_overlap_on_1 > min_overlap & 
                 percent_overlap_on_2 > min_overlap]
  
  # subsetting the bed files
  reference_bed <- reference_bed[queryHits(hits)]
  subject_bed <- subject_bed[subjectHits(hits)]
  
  # "reducing" the peaks
  reduced_start <- pmin(start(reference_bed), 
                        start(subject_bed))
  reduced_end <- pmax(end(reference_bed), 
                      end(subject_bed))
  start(reference_bed) <- reduced_start
  end(reference_bed) <- reduced_end
  
  return(reference_bed)
  
}

```

```{r}

# overlapping peaks in HL60-0h ref.
hl60_bed_files <- bed_files[1:3] 
hl60_reference_bed <- import(hl60_bed_files[1])
for(i in 2:length(hl60_bed_files)){
  
  # loading the bed file
  subject_bed <- import(hl60_bed_files[i])
  
  # intersecting
  hl60_reference_bed <- find_intersection(hl60_reference_bed, subject_bed, chromosomes)
  
}

# overlapping peaks in Neu-3h
Neu3h_bed_files <- bed_files[4:6] 
Neu3h_reference_bed <- import(Neu3h_bed_files[1])
for(i in 2:length(Neu3h_bed_files)){
  
  # loading the bed file
  subject_bed <- import(Neu3h_bed_files[i])
  
  # intersecting
  Neu3h_reference_bed <- find_intersection(Neu3h_reference_bed, subject_bed, chromosomes)
  
}

# overlapping peaks in Neu-6h
Neu6h_bed_files <- bed_files[7:9] 
Neu6h_reference_bed <- import(Neu6h_bed_files[1])
for(i in 2:length(Neu6h_bed_files)){
  
  # loading the bed file
  subject_bed <- import(Neu6h_bed_files[i])
  
  # intersecting
  Neu6h_reference_bed <- find_intersection(Neu6h_reference_bed, subject_bed, chromosomes)
  
}

# overlapping peaks in Neu-12h
Neu12h_bed_files <- bed_files[10:12] 
Neu12h_reference_bed <- import(Neu12h_bed_files[1])
for(i in 2:length(Neu12h_bed_files)){
  
  # loading the bed file
  subject_bed <- import(Neu12h_bed_files[i])
  
  # intersecting
  Neu12h_reference_bed <- find_intersection(Neu12h_reference_bed, subject_bed, chromosomes)
  
}
# how many peaks?
length(hl60_reference_bed)
length(Neu3h_reference_bed)
length(Neu6h_reference_bed)
length(Neu12h_reference_bed)

```

```{r}
# peak union!
union_reference_bed <- c(hl60_reference_bed,Neu3h_reference_bed,Neu6h_reference_bed,Neu12h_reference_bed)
length(union_reference_bed)

# reducing: concatenating intervals that are overlapping
union_reference_bed <- reduce(union_reference_bed)
length(union_reference_bed)

# loading black listed regions
# https://www.encodeproject.org/annotations/ENCSR636HFF/
black_listed_bed <- import('ENCFF356LFX.bed')

# any hit?
hits <- findOverlaps(union_reference_bed, black_listed_bed)
hits

# what about the length of the overlap?
overlaps <- pintersect(union_reference_bed[queryHits(hits)], 
                       black_listed_bed[subjectHits(hits)])
summary(width(overlaps)/width(union_reference_bed[queryHits(hits)]))

# eliminating the blacklisted regions
union_reference_bed <- union_reference_bed[-queryHits(hits)]

# writing the reference
export.bed(union_reference_bed, con = 'refererence.bed')
```

## From bw to count

Description

```{r}
# Script for coverting bigWig + bed files to counts
# Partially adapted from https://lcolladotor.github.io/protocols/bigwig_DEanalysis/

# set up
rm(list = ls())
library(rtracklayer)
library(GenomicRanges)

# control panel
raw_data_folder <- './ATACseq/bws/'
#according to paper methods average read length is 80 (ale had 36)
read_length <- 80
chromosomes <- paste0('chr', c(1:22, 'X', 'Y'))
reference_file <- './refererence.bed'

# bw files
bw_files <- file.path(raw_data_folder, dir(raw_data_folder, pattern = '*.bw'))
bw_files <- bw_files[1:12]

# loading reference bed
peaks <- import(reference_file)

# count matrix
count_matrix <- matrix(0, length(peaks), length(bw_files))
rownames(count_matrix) <- paste0(seqnames(peaks), '_', start(peaks), '_', end(peaks))
colnames(count_matrix) <- letters[1:length(bw_files)]

# looping over files
for(i in 1:length(bw_files)){
  
  # current files
  print(paste0('sample ', i, ' out of ', length(bw_files)))
  bw_file <- bw_files[i]
  
  # sample name
  sample_name <- gsub(raw_data_folder, '', bw_file, fixed = TRUE)
  sample_name <- gsub('.bw', '', sample_name, fixed = TRUE)
  sample_name <- gsub('/', '', sample_name, fixed = TRUE)
  sample_name <- strsplit(sample_name, '_')[[1]][2]
  sample_name <- paste0('T', sample_name) 
  
  # loadind and downsizing the bigwigfile
  bw_file_list <- BigWigFileList(bw_file)
  coverage <- import(bw_file_list[[1]], as = 'RleList')
  # head(coverage)
  coverage <- coverage[names(coverage) %in% chromosomes]
  
  # split the peaks across chromosomes
  peaks_list <- split(peaks, seqnames(peaks))
  #to_keep <- which(sapply(peaks_list, length) > 0)
  #peaks_list <- peaks_list[to_keep]
  
  # ensuring peaks list and coverage have the same chromosomes
  common_chromosomes <- intersect(names(coverage), 
                                   as.character(unique(seqnames(peaks_list))))
   peaks_list <- peaks_list[names(peaks_list) %in% common_chromosomes]
   coverage <- coverage[names(coverage) %in% common_chromosomes]
  
  # coverage per peak
  coverage <- coverage[names(peaks_list)]
  peaks_coverage <- Views(coverage, ranges(peaks_list))
  # peaks_coverage$chr1
  # peaks_coverage$chr1[[1]]
  
  # count values
  counts <- sapply(peaks_coverage, sum)
  # head(counts$chr1) 
  # sum(sapply(counts, length))
  # length(peaks)
  
  # ensuring to have the right peak information
  chrs <- rep(names(peaks_coverage), sapply(peaks_coverage, length))
  starts <- sapply(peaks_coverage, start)
  ends <- sapply(peaks_coverage, end)

  # converting to vector
  counts <- unlist(counts)
  names(counts) <- paste0(chrs, '_', unlist(starts), '_', unlist(ends))
  # head(counts)
  
  # rounding up
  counts <- round(counts / read_length)
  # head(counts)
  
  # fractions of reads in peaks
  sum(counts)
  all_counts <- sapply(coverage, sum)
  all_counts <- sum(all_counts)
  all_counts <- round(all_counts / read_length)
  all_counts
  sum(counts) / all_counts
  
  # count as data frame
  count_matrix[names(counts), i] <- counts
  colnames(count_matrix)[i] <- sample_name
  # head(count_matrix)
  
}

# writing
count_matrix <- as.data.frame(count_matrix)
count_matrix <- cbind(peak = rownames(count_matrix), count_matrix)
head(count_matrix)
write.csv(count_matrix, row.names = FALSE,
          file = 'count_matrix_v2.csv')
```

## Differential analysis

Description

```{r}
library(DESeq2)
library(ggplot2)
library(ChIPseeker)
library(rtracklayer)
library(clusterProfiler)
library(chipenrich)
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene

# control panel
#I remove the LFC treshold since in the paper they dont filter by LFC.
#lfc_threshold <- 1 
sign_threshold <- 0.05

# load count matrix
count_matrix <- read.csv('./count_matrix_v2.csv')
rownames(count_matrix) <- count_matrix$peak
count_matrix$peak <- NULL
head(count_matrix)

# pheno information
pheno <- data.frame(
  cell_type = factor(c(rep('HL60', 3), rep('Neu3h', 3), rep('Neu6h', 3), rep('Neu12h', 3)))
)
#pheno$cell_type <- relevel(pheno$cell_type, ref = 'Neu3h')

# Deseq object
dds <- DESeqDataSetFromMatrix(countData = count_matrix,
                              colData = pheno,
                              design = ~ cell_type)

# PCA
log_count_matrix <- rlog(dds)
p <- plotPCA(log_count_matrix, intgroup = 'cell_type')
p <- p + 
  scale_color_discrete(name = 'Cell type') + 
  theme_bw()
plot(p)

# any batch effect?

# differential accessibility
dds <- DESeq(dds)
#res <- as.data.frame(results(dds))
#head(res)
#set alpha parameter to keep same FDR treshold as in the paper (FDR 1%)
res_Neu3h_vs_hl60 <- results(dds, contrast = c("cell_type", "Neu3h", "HL60"), alpha = 0.01)
res_Neu6h_vs_Neu3h <- results(dds, contrast = c("cell_type", "Neu6h", "Neu3h"), alpha = 0.01)
res_Neu12h_vs_Neu6h <- results(dds, contrast = c("cell_type", "Neu12h", "Neu6h"), alpha = 0.01)

#head(res_Neu6h_vs_Neu3h)
#head(res_Neu12h_vs_Neu3h)
#head(res_Neu12h_vs_Neu6h)

#Better visualization with summary instead of head 
summary(res_Neu3h_vs_hl60)
summary(res_Neu6h_vs_Neu3h)
summary(res_Neu12h_vs_Neu6h)

```

# NO SIGNIFICANCE ?
I found significant only from 0 to 3h but much more than in the paper.
I believe this difference is because they did this analysis with a different tool maSigPro. We need to 
read about it and the differences with DESeq2 to try to explain why was different 
filtering 
```{r}
# differentially accessible peaks based on threshold

sign_idx_3vs0 = as.data.frame(res_Neu3h_vs_hl60)[which(res_Neu3h_vs_hl60$padj < 0.01),]
nrow(sign_idx_3vs0)

sign_idx_6vs3 = as.data.frame(res_Neu6h_vs_Neu3h)[which(res_Neu6h_vs_Neu3h$padj < 0.01),]
nrow(sign_idx_6vs3)

sign_idx_12vs6 = as.data.frame(res_Neu12h_vs_Neu6h)[which(res_Neu12h_vs_Neu6h$padj < 0.01),]
nrow(sign_idx_12vs6)

```

